
import os  # for os.path.basename

import matplotlib.pyplot as plt
import matplotlib as mpl

from sklearn.manifold import MDS
import joblib
import argparse
import random
import pandas as pd
from cluster_classes import load_mappings,format_type

MDS()

type_to_subject_matter_mapping,type_to_service_mapping,type_to_source_mapping = load_mappings()

def get_label(name,axes):
	# print(type(name))
	fname = format_type(name)
	if not fname:
		return name
	if(axes == 'subject'):
		if fname not in type_to_subject_matter_mapping:
			return name
		return type_to_subject_matter_mapping[fname]
	elif(axes == 'service'):
		if fname not in type_to_service_mapping:
			return name
		return type_to_service_mapping[fname]
	elif (axes == 'source'):
		if fname not in type_to_source_mapping:
			return name
		return type_to_source_mapping[fname]
	else:
		return name

def plot(tfidf,km,types,output,axes='default'):
	mds = MDS(n_components=2, dissimilarity="euclidean", random_state=1)

	dist = tfidf
	pos = mds.fit_transform(dist)  # shape (n_components, n_samples)

	xs, ys = pos[:, 0], pos[:, 1]
	print()
	print()

	clusters = km.labels_.tolist()

	num_clusters = len(set(clusters))

	cluster_colors = ["#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])
			 for i in range(num_clusters)]

	df = pd.DataFrame(dict(x=xs, y=ys, label=clusters, title=types)) 
	groups = df.groupby('label')

	# set up plot
	fig, ax = plt.subplots(figsize=(68, 50)) # set size
	ax.margins(0.05) # Optional, just adds 5% padding to the autoscaling

	#iterate through groups to layer the plot
	#note that I use the cluster_name and cluster_color dicts with the 'name' lookup to return the appropriate color/label
	for name, group in groups:
		ax.plot(group.x, group.y, marker='o', linestyle='', ms=12, 
				label=name, color=cluster_colors[name], 
				mec='none')
		ax.set_aspect('auto')
		ax.tick_params(\
			axis= 'x',          # changes apply to the x-axis
			which='both',      # both major and minor ticks are affected
			bottom='off',      # ticks along the bottom edge are off
			top='off',         # ticks along the top edge are off
			labelbottom='off')
		ax.tick_params(\
			axis= 'y',         # changes apply to the y-axis
			which='both',      # both major and minor ticks are affected
			left='off',      # ticks along the bottom edge are off
			top='off',         # ticks along the top edge are off
			labelleft='off')
		
	ax.legend(numpoints=1)  #show legend with only 1 point

	#add label in x,y position with the label as the film title
	for i in range(len(df)):
		ax.text(df.ix[i]['x'], df.ix[i]['y'], get_label(df.ix[i]['title'],axes), size=8)  

	
	
	plt.show() #show the plot

	#uncomment the below to save the plot if need be
	plt.savefig(output, dpi=200)


if __name__== "__main__":

	parser = argparse.ArgumentParser(description="Load the tfidf matrix and store calculated clusters in a pkl file")
	parser.add_argument('data',help='Data pkl generated by load_data')
	parser.add_argument('tfidf',help="Tfidf_matrix generated by tfidf.py")
	parser.add_argument('clusters',help="Clusters generated by cluster_data.py")
	parser.add_argument('output', help='Output file (.pkl) that contains created clusters.')
	parser.add_argument('--axes',help='Choose between subject,service,source and default')
	parser.add_argument('--field',help='Choose between type and name, default type')


	args = parser.parse_args()

	print("Loading tfidf data")
	tfidf = joblib.load(args.tfidf)
	try: 
		tfidf_matrix = tfidf.toarray() 
	except AttributeError:
		tfidf_matrix = tfidf
	km = joblib.load(args.clusters)
	data = joblib.load(args.data)

	axes = args.axes
	if not (args.axes):
		axes ='default'
	field = 'type'
	if args.field:
		field = args.field

	plot(tfidf_matrix,km,data[field],args.output,axes)



